# 🍲️ 식당 예약 서버

각종 레스토랑(식당) 예약을 위한 스프링 서버

## 🧑🏻‍💻 프로젝트 시스템

본 서버에서는 각종 레스토랑의 예약, 예약 변경, 취소 등 전반적인 예약 시스템을 지원합니다.

- **/api/v1/user/~** : 회원가입, 유저 페이지 등 유저와 관련된 서비스를 제공합니다.
- **/api/v1/restaurant/~** : 레스토랑 등록, 레스토랑 상세 페이지 및 리스트 등의 서비스를 제공합니다.
- **/api/v1/reservation/~** : 예약 관련 서비스로 유저의 예약 목록, 예약, 예약 취소/변경/확인 등을 제공합니다. 
- **TimeSlot 엔티티** : 예약이 가능한 시간대 정보 엔티티로 해당 시간대의 예약자 수를 관리하고 예약 가능/불가능의 판단을 담당합니다.
- **토큰 기반 인증(로그인)** : JWT를 기반으로 토큰 인증 서비스를 제공합니다. 
- **동시성 처리(OptimisticLock)** : OptimisticLock 방식을 도입하여 동시간대 예약에 대한 동시성 문제를 통제하도록 했습니다. 
- **예외 핸들러 등록** : 글로벌 예외 핸들러를 등록하여 서버 내에서 발생하는 예외에 대한 처리를 담당합니다.

## 📦 프로젝트(패키지) 구조
```markdown
app/
├── domain/
│   ├── application/
│   │   ├── mapper/ (엔터티 <-> DTO, DTO <-> 엔터티, 매핑 클래스)
│   │   ├── port/
│   │   │   ├── in/ (UseCase)
│   │   │   └── out/ (Port)
│   │   └── service/ (도메인 서비스 구현체)
│   ├── domain/ (도메인 엔터티)
│   ├── infrastructure/
│   │   ├── adapter/ (JpaPort 구현체)
│   │   └── repository/ (레포지토리)
│   └── presentation/
│   │   ├── controller/ (컨트롤러)
│   │   └── dto/ (DTO)
└── global/
    ├── config/ (각종 서버 환경 설정 및 인증 시스템 설정)
    ├── exception/ (예외 클래스)
    └── util/ (각종 유틸 클래스)
```

## 🏛️ 아키텍처 특징
이 프로젝트는 **헥사고날 아키텍처(Hexagonal Architecture)**, 즉 **포트 & 어댑터(Ports & Adapters) 패턴**을 기반으로 설계되었습니다.

- **도메인 중심 설계(Domain-Driven Design)** 를 기반으로 각 도메인을 독립적으로 구성하고, 비즈니스 로직과 외부 의존성을 분리했습니다.
- 도메인 서비스는 **포트(Port) 인터페이스**를 통해 의존성을 선언하고, 실제 구현은 **어댑터(Adapter)** 에서 처리하여 의존성을 역전시켰습니다.
- 이를 통해 비즈니스 로직이 외부 환경에 의존하지 않고, **유지보수성을 극대화**했습니다.

### domain

- **application** : 도메인 로직을 조율하는 서비스 계층으로, UseCase 인터페이스와 구현체를 통해 프레젠테이션과 도메인 사이의 흐름을 관리합니다.
    - **mapper** : 엔터티 ↔ DTO 간 변환을 담당하는 매핑 클래스가 위치합니다.
    - **port** : 의존성을 조율하는 계층으로 UseCase 인터페이스를 정의하고 도메인의 외부(컨트롤러 등)에서 호출할 수 있는 서비스 계약을 선언하는 **in**패키지와 Port 인터페이스를 정의하고 외부 인프라에 대한 의존성을 추상화하는 **out**패키지로 나뉩니다.
    - **service** : 도메인 비즈니스 로직을 담은 서비스 클래스로 UseCase 구현체 역할을 수행합니다.
- **domain** : 해당 도메인의 엔터티와 애그리거트 루트 등 핵심 도메인 모델이 존재하는 계층입니다.
- **infrastructure** : 포트의 구현체인 Adapter와 영속성 처리를 담당하는 Repository가 포함된 계층입니다.
    - **adapter** : Port 인터페이스를 구현하여 실제 외부 시스템과 연결되는 어댑터 클래스가 위치합니다.
    - **repository** : JPA/Hibernate 등의 영속성 구현체로 Repository 인터페이스 혹은 Spring Data JPA 레포지토리 클래스가 위치합니다.
- **presentation** : 사용자의 요청과 응답을 처리하는 컨트롤러와 DTO가 존재하는 계층입니다. API 엔드포인트를 제공하며, 요청을 UseCase 또는 Service에 전달하고 결과를 반환합니다.
    - **controller** : HTTP API 요청을 처리하는 컨트롤러 클래스가 위치합니다.
    - **dto** : 클라이언트와 데이터를 교환하기 위한 요청/응답 DTO 클래스가 위치합니다.

### global

- **config** : JWT 관련 인증 보안을 포함한 전체적인 서버 시큐리티 설정을 담당하는 패키지입니다.
- **exception** : 사용자 정의 예외 클래스가 속한 패키지입니다.
- **util** : 프로젝트 전역에서 활용할 각종 유틸리티 클래스들이 위치합니다.

## 🧐 개선 가능 사항

- **동시성 처리 개선** : 현재 예약 처리 로직은 Optimistic Lock 기반으로 최대 5회까지 재시도하도록 구현되어 있습니다. 

  이 방식은 일반적인 트래픽 환경에서는 유효하지만, 인기 레스토랑이나 특정 시간대에 예약 요청이 집중되는 상황에서는 재시도 횟수 증가로 인해 응답 지연 및 불필요한 DB 부하가 발생할 수 있는 한계가 있습니다. 

  이를 개선하기 위해 다음과 같은 방안을 고려할 수 있습니다.

    - **Pessimistic Lock 도입** : 특정 레스토랑 및 시간대(TimeSlot)를 기준으로 DB 레벨에서 락을 선점하여, 최초 요청만 처리하고 이후 요청은 대기하도록 설계하면 충돌 자체를 사전에 차단함으로서 안정성을 높일 수 있습니다. 
    - **Redis 기반 분산 락 적용** : 단일 DB 락에 의존하지 않고 Redis를 활용해 레스토랑·시간대 단위의 분산 락을 구현하여 하이트래픽 상황에서도 안정적인 동시성 처리가 가능합니다. 


- **예약 디테일 개선** : 현재 시스템은 레스토랑 단위로 최대 예약 가능 인원(또는 테이블 수)을 설정하고, 시간대(TimeSlot)별로 예약 가능 여부를 관리하는 구조입니다. 

  이 방식은 구현이 단순하지만, 모든 좌석을 동일한 자원으로 취급하기 때문에 실제 레스토랑 운영 시나리오를 충분히 반영하지 못하는 한계가 있습니다.

  이를 개선하기 위해 Table이나 Seat 엔티티를 추가해 테이블 전호, 테이블 유형 등 다양성을 부여하여 사용자에게 자리 선택 옵션을 제공할 수 있습니다. 


- **Redis 캐싱** : 현재 조회 API는 매 요청마다 DB 접근을 통해 DTO를 생성하고 반환하는 구조로, 

  트래픽 증가 시 조회성 API가 DB 부하의 주요 원인이 될 가능성이 있습니다. 

  이를 개선하기 위해 Redis 캐싱을 도입하여 변경 빈도가 낮고 조회 빈도가 높은 데이터를 캐싱해 성능 개선 및 서버 부하 감소의 효과를 볼 수 있습니다. 


- **상호작용 서비스 추가** : 현재는 레스토랑 등록과 예약 등 기본적인 예약 시스템만 구성되어 있지만 레스토랑 별점이나 사용자가 리뷰를 작성할 수 있게끔 하여 사용자 측면에서 상호작용할 수 있는 시스템을 추가하는 방식도 고려할 수 있을 것 같습니다. 