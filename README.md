# 🍲️ 식당 예약 서버

각종 레스토랑(식당) 예약을 위한 스프링 서버

## 🧑🏻‍💻 프로젝트 시스템

본 서버에서는 각종 레스토랑의 예약, 예약 변경, 취소 등 전반적인 예약 시스템을 지원합니다.

- **User API(/api/v1/user/~, /login)**
  - 회원가입, 로그인, 사용자 정보 조회 등 유저 도메인의 생명주기 관리를 담당합니다.
  - JWT 기반 인증 구조와 연계되어, 토큰 발급·검증을 통한 Stateless 인증 흐름의 진입점 역할을 합니다.
  - 인증된 사용자 컨텍스트(@AuthenticationPrincipal)를 기반으로 다른 도메인과의 연관 관계를 안전하게 연결합니다.
- **Restaurant API(/api/v1/restaurant/~)**
  - 레스토랑 등록, 상세 조회, 목록 조회 기능을 제공합니다.
  - TimeSlot 엔티티와 최대 예약 가능 수를 이용해 예약을 받도록 합니다.
  - 조회 성격이 강한 API 특성을 고려해 향후 캐싱 또는 검색 엔진(Elasticsearch) 확장 가능성을 염두한 구조로 구현했습니다. 
- **Reservation API(/api/v1/reservation/~)** 
  - 예약 생성, 확인, 취소, 변경 및 사용자별 예약 목록 조회를 담당합니다.
  - 예약 생성/변경 시 TimeSlot 점유 처리와 예약 상태 전이를 하나의 트랜잭션에서 처리합니다.
  - 실제 예약 시간과 예약 자리 수와 관련된 동작은 TimeSlot 도메인에서 처리하게 하여 도메인을 철저히 분리했습니다. 
- **TimeSlot 엔티티** 
  - 레스토랑별 예약 가능한 시간 단위를 표현하는 도메인 엔티티입니다. 
  - 현재 예약 수, 최대 예약 수 초과 여부 판단, 예약 가능/불가능 판단의 책임을 지는 도메인의 엔티티입니다. 
  - 단순한 데이터 저장소가 아닌, 동시성 제어의 핵심 도메인 객체로 설계하여 예약 생성·취소·변경 시 항상 TimeSlot을 통해 상태를 검증합니다. 
- **토큰 기반 인증(로그인)** 
  - 서버 세션을 사용하지 않는 Stateless 인증 구조로 Access Token 기반으로 요청을 인증하고 Spring Security Filter Chain에서 토큰 검증 및 인증 객체를 생성합니다. 
- **동시성 처리(OptimisticLock)** 
  - TimeSlot 엔티티에 @Version을 적용하여 동시간대 예약 요청 충돌을 감지하는 동시성 처리 방식 중 하나입니다. 
  - 충동 발생 시 재조회 및 재시도를 하게 되며 DB 락 점유 시간을 최소화하여 일반적인 트래픽 상황에서 높은 처리량을 유지할 수 있는 구조입니다.
- **예외 핸들러 등록** : 글로벌 예외 핸들러를 등록하여 서버 내에서 발생하는 예외에 대한 처리를 담당합니다.

## 📦 프로젝트(패키지) 구조
```markdown
app/
├── domain/
│   ├── application/
│   │   ├── mapper/ (엔터티 <-> DTO, DTO <-> 엔터티, 매핑 클래스)
│   │   ├── port/
│   │   │   ├── in/ (UseCase)
│   │   │   └── out/ (Port)
│   │   └── service/ (도메인 서비스 구현체)
│   ├── domain/ (도메인 엔터티)
│   ├── infrastructure/
│   │   ├── adapter/ (JpaPort 구현체)
│   │   └── repository/ (레포지토리)
│   └── presentation/
│   │   ├── controller/ (컨트롤러)
│   │   └── dto/ (DTO)
└── global/
    ├── config/ (각종 서버 환경 설정 및 인증 시스템 설정)
    ├── exception/ (예외 클래스)
    └── util/ (각종 유틸 클래스)
```

## 🏛️ 아키텍처 특징
이 프로젝트는 **헥사고날 아키텍처(Hexagonal Architecture)**, 즉 **포트 & 어댑터(Ports & Adapters) 패턴**을 기반으로 설계되었습니다.

- **도메인 중심 설계(Domain-Driven Design)** 를 기반으로 각 도메인을 독립적으로 구성하고, 비즈니스 로직과 외부 의존성을 분리했습니다.
- 도메인 서비스는 **포트(Port) 인터페이스**를 통해 의존성을 선언하고, 실제 구현은 **어댑터(Adapter)** 에서 처리하여 의존성을 역전시켰습니다.
- 이를 통해 비즈니스 로직이 외부 환경에 의존하지 않고, **유지보수성을 극대화**했습니다.

### domain

- **application** : 도메인 로직을 조율하는 서비스 계층으로, UseCase 인터페이스와 구현체를 통해 프레젠테이션과 도메인 사이의 흐름을 관리합니다.
    - **mapper** : 엔터티 ↔ DTO 간 변환을 담당하는 매핑 클래스가 위치합니다.
    - **port** : 의존성을 조율하는 계층으로 UseCase 인터페이스를 정의하고 도메인의 외부(컨트롤러 등)에서 호출할 수 있는 서비스 계약을 선언하는 **in**패키지와 Port 인터페이스를 정의하고 외부 인프라에 대한 의존성을 추상화하는 **out**패키지로 나뉩니다.
    - **service** : 도메인 비즈니스 로직을 담은 서비스 클래스로 UseCase 구현체 역할을 수행합니다.
- **domain** : 해당 도메인의 엔터티와 애그리거트 루트 등 핵심 도메인 모델이 존재하는 계층입니다.
- **infrastructure** : 포트의 구현체인 Adapter와 영속성 처리를 담당하는 Repository가 포함된 계층입니다.
    - **adapter** : Port 인터페이스를 구현하여 실제 외부 시스템과 연결되는 어댑터 클래스가 위치합니다.
    - **repository** : JPA/Hibernate 등의 영속성 구현체로 Repository 인터페이스 혹은 Spring Data JPA 레포지토리 클래스가 위치합니다.
- **presentation** : 사용자의 요청과 응답을 처리하는 컨트롤러와 DTO가 존재하는 계층입니다. API 엔드포인트를 제공하며, 요청을 UseCase 또는 Service에 전달하고 결과를 반환합니다.
    - **controller** : HTTP API 요청을 처리하는 컨트롤러 클래스가 위치합니다.
    - **dto** : 클라이언트와 데이터를 교환하기 위한 요청/응답 DTO 클래스가 위치합니다.

### global

- **config** : JWT 관련 인증 보안을 포함한 전체적인 서버 시큐리티 설정을 담당하는 패키지입니다.
- **exception** : 사용자 정의 예외 클래스가 속한 패키지입니다.
- **util** : 프로젝트 전역에서 활용할 각종 유틸리티 클래스들이 위치합니다.

## 🧬 Table Tree 구조도(MySQL)
![diagram](img/diagram.png)

## 🧐 개선 가능 사항

- **동시성 처리 개선** : 현재 예약 처리 로직은 Optimistic Lock 기반으로 최대 5회까지 재시도하도록 구현되어 있습니다. 

  이 방식은 일반적인 트래픽 환경에서는 유효하지만, 인기 레스토랑이나 특정 시간대에 예약 요청이 집중되는 상황에서는 재시도 횟수 증가로 인해 응답 지연 및 불필요한 DB 부하가 발생할 수 있는 한계가 있습니다. 

  이를 개선하기 위해 다음과 같은 방안을 고려할 수 있습니다.

    - **Pessimistic Lock 도입** : 특정 레스토랑 및 시간대(TimeSlot)를 기준으로 DB 레벨에서 락을 선점하여, 최초 요청만 처리하고 이후 요청은 대기하도록 설계하면 충돌 자체를 사전에 차단함으로서 안정성을 높일 수 있습니다. 
    - **Redis 기반 분산 락 적용** : 단일 DB 락에 의존하지 않고 Redis를 활용해 레스토랑·시간대 단위의 분산 락을 구현하여 하이트래픽 상황에서도 안정적인 동시성 처리가 가능합니다. 


- **예약 디테일 개선** : 현재 시스템은 레스토랑 단위로 최대 예약 가능 인원(또는 테이블 수)을 설정하고, 시간대(TimeSlot)별로 예약 가능 여부를 관리하는 구조입니다. 

  이 방식은 구현이 단순하지만, 모든 좌석을 동일한 자원으로 취급하기 때문에 실제 레스토랑 운영 시나리오를 충분히 반영하지 못하는 한계가 있습니다.

  이를 개선하기 위해 Table이나 Seat 엔티티를 추가해 테이블 전호, 테이블 유형 등 다양성을 부여하여 사용자에게 자리 선택 옵션을 제공할 수 있습니다. 


- **Redis 캐싱** : 현재 조회 API는 매 요청마다 DB 접근을 통해 DTO를 생성하고 반환하는 구조로, 

  트래픽 증가 시 조회성 API가 DB 부하의 주요 원인이 될 가능성이 있습니다. 

  이를 개선하기 위해 Redis 캐싱을 도입하여 변경 빈도가 낮고 조회 빈도가 높은 데이터를 캐싱해 성능 개선 및 서버 부하 감소의 효과를 볼 수 있습니다. 


- **상호작용 서비스 추가** : 현재는 레스토랑 등록과 예약 등 기본적인 예약 시스템만 구성되어 있지만 레스토랑 별점이나 사용자가 리뷰를 작성할 수 있게끔 하여 사용자 측면에서 상호작용할 수 있는 시스템을 추가하는 방식도 고려할 수 있을 것 같습니다. 
